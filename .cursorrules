## ðŸš¨ CRITICAL: useEffect Policy

This project AVOIDS useEffect unless absolutely necessary. Before using useEffect, you MUST:
1. Explain why it's needed
2. Prove it can't be done with TanStack Query, event handlers, or render calculations
3. Show proper cleanup if dealing with external systems

Default assumption: You don't need useEffect. Prove otherwise.

# Personal Finance Tracker - Cursor Rules

## Project Context
Building a personal finance tracking MVP for real-time budget decisions. Focus on simplicity, type safety, and fast iteration.

## Tech Stack
- React 18 + TypeScript + Vite
- Supabase (auth, database, real-time)
- TanStack Query v5 for server state
- Tailwind CSS for styling
- shadcn/ui for components (optional but recommended)
- Claude API for AI assistant

## Code Style & Patterns

### TypeScript
- Use strict mode
- Prefer interfaces for objects, types for unions/intersections
- No `any` - use `unknown` if type is truly unknown
- Use Zod for runtime validation where needed
- Export types from separate `.types.ts` files

### React
- Functional components only
- Use hooks (useState, useEffect, custom hooks)
- Keep components small (<200 lines)
- Co-locate related code (component + styles + types in same folder)
- Use custom hooks for business logic extraction

### TanStack Query
- Use query keys as constants: `['liabilities', userId]`
- Implement optimistic updates for mutations
- Use `queryClient.invalidateQueries()` after mutations
- Keep queries close to where they're used
- Example pattern:
```typescript
const { data, isLoading } = useQuery({
  queryKey: ['liabilities', userId],
  queryFn: () => supabase.from('liabilities').select('*'),
})
```

### Supabase
- Use Row Level Security (RLS) policies
- Type-safe queries using generated types
- Handle errors gracefully with try-catch
- Use real-time subscriptions sparingly (only for critical data)

### File Structure
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/              # shadcn components
â”‚   â”œâ”€â”€ dashboard/       # dashboard specific
â”‚   â”œâ”€â”€ expenses/        # expense related
â”‚   â””â”€â”€ shared/          # reusable components
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”œâ”€â”€ useLiabilities.ts
â”‚   â””â”€â”€ useAffordability.ts
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ supabase.ts      # client setup
â”‚   â”œâ”€â”€ queryClient.ts   # tanstack setup
â”‚   â””â”€â”€ utils.ts
â”œâ”€â”€ types/
â”‚   â”œâ”€â”€ database.types.ts # generated from Supabase
â”‚   â””â”€â”€ app.types.ts      # app-specific types
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ claude.ts         # AI API calls
â”‚   â””â”€â”€ calculations.ts   # finance logic
â””â”€â”€ pages/
â”œâ”€â”€ Dashboard.tsx
â”œâ”€â”€ Expenses.tsx
â””â”€â”€ Settings.tsx

### Naming Conventions
- Components: PascalCase (UserProfile.tsx)
- Hooks: camelCase with 'use' prefix (useAffordability.ts)
- Utils: camelCase (formatCurrency.ts)
- Constants: UPPER_SNAKE_CASE (QUERY_KEYS.ts)
- Types/Interfaces: PascalCase (Liability, ExpenseItem)

### Philippine-Specific Requirements
- Currency: Always PHP (â‚±)
- Date format: MM/DD/YYYY (PH standard)
- Payment methods: Cash, GCash, PayMaya, Credit Cards (common PH cards)
- Common loan apps: Atome, BillEase, Home Credit
- E-commerce: Lazada, Shopee installments

### Error Handling
- Always handle Supabase errors
- Show user-friendly error messages
- Log errors to console in development
- Use toast notifications for user feedback

### Performance
- Lazy load routes with React.lazy()
- Memoize expensive calculations
- Use TanStack Query's caching effectively
- Optimize re-renders with React.memo where needed

### Security
- Never expose API keys in client code
- Use environment variables for sensitive data
- Validate all user inputs
- Implement RLS policies on all Supabase tables

### AI Integration
- Use Claude API via edge function or backend proxy (never expose API key)
- Send minimal context to AI (user's financial summary, not raw data)
- Cache AI responses where appropriate
- Handle API failures gracefully

## DO's
- Write self-documenting code
- Use TypeScript strictly
- Implement loading and error states
- Test edge cases (negative numbers, large amounts)
- Make it mobile-responsive (primary use case)
- Add helpful comments for complex finance calculations

## DON'Ts
- Don't use class components
- Don't ignore TypeScript errors
- Don't store sensitive data in localStorage (use Supabase)
- Don't make unnecessary API calls
- Don't skip error boundaries
- Don't hardcode values that should be configurable

## React Patterns - AVOID useEffect

### â›” NEVER use useEffect for:
1. **Data fetching** - Use TanStack Query instead
2. **Derived state** - Calculate during render or use useMemo
3. **Event handlers** - Put logic directly in handlers
4. **Syncing state** - Lift state up or use proper state management

### âœ… CORRECT Patterns:

**âŒ BAD - useEffect for data fetching:**
```typescript
const [data, setData] = useState(null);

useEffect(() => {
  fetchData().then(setData);
}, []);
```

**âœ… GOOD - TanStack Query:**
```typescript
const { data } = useQuery({
  queryKey: ['data'],
  queryFn: fetchData
});
```

---

**âŒ BAD - useEffect for derived state:**
```typescript
const [total, setTotal] = useState(0);

useEffect(() => {
  setTotal(expenses.reduce((sum, e) => sum + e.amount, 0));
}, [expenses]);
```

**âœ… GOOD - Calculate during render:**
```typescript
const total = expenses.reduce((sum, e) => sum + e.amount, 0);
// Or if expensive:
const total = useMemo(
  () => expenses.reduce((sum, e) => sum + e.amount, 0),
  [expenses]
);
```

---

**âŒ BAD - useEffect for syncing props to state:**
```typescript
useEffect(() => {
  setLocalValue(propValue);
}, [propValue]);
```

**âœ… GOOD - Use props directly or controlled component:**
```typescript
// Just use propValue directly, or:
const [value, setValue] = useState(propValue);
// Only initialize once, update via handlers
```

---

**âŒ BAD - useEffect for event handling:**
```typescript
useEffect(() => {
  if (isSubmitted) {
    saveData();
  }
}, [isSubmitted]);
```

**âœ… GOOD - Direct event handler:**
```typescript
const handleSubmit = async () => {
  await saveData();
  setIsSubmitted(true);
};
```

---

### âš ï¸ RARE Valid useEffect Uses:

Only use useEffect for TRUE side effects:

1. **External system sync** (WebSocket, browser APIs):
```typescript
useEffect(() => {
  const ws = new WebSocket('ws://...');
  ws.onmessage = handleMessage;
  return () => ws.close(); // cleanup
}, []);
```

2. **DOM manipulation** (rare, usually refs are better):
```typescript
useEffect(() => {
  inputRef.current?.focus();
}, []);
```

3. **Third-party library integration** (non-React libs):
```typescript
useEffect(() => {
  const chart = initChart(canvasRef.current);
  return () => chart.destroy();
}, [data]);
```

### ðŸŽ¯ Decision Tree:
Need to do something?
â”œâ”€ Fetching data? â†’ TanStack Query
â”œâ”€ Computing value? â†’ Render calculation or useMemo
â”œâ”€ Responding to user action? â†’ Event handler
â”œâ”€ Syncing with external system? â†’ useEffect (rare)
â””â”€ Everything else? â†’ Probably don't need useEffect

### General Rule:
**If you're about to write useEffect, STOP and ask:**
1. Can TanStack Query handle this? (data fetching/mutations)
2. Can I calculate this during render? (derived state)
3. Can I put this in an event handler? (user interactions)
4. Is this truly an external side effect? (if no, don't use useEffect)

**95% of the time, useEffect is not the answer.**

### Code Review Checklist:
- [ ] No useEffect for data fetching (use TanStack Query)
- [ ] No useEffect for derived state (calculate or useMemo)
- [ ] No useEffect for syncing state
- [ ] useEffect only for external systems with cleanup